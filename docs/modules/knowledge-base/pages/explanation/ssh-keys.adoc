= SSH Keys Explanation

SSH keys are a highly secure replacement for the use of passwords when communicating with a remote machine or service. In order to use them, you need to generate a key pair using a command line tool, such as `ssh-keygen`, and configure your local machine to use the private key, then copy the public key into the SSH settings of the service, such as GitHub, GitLab, or Bitbucket. When generating the keys, you can password-protect the private key to further enhance security, preventing unauthorized access even if the private key is compromised.

== What are SSH Keys useful for?

They are particularly useful for:

*Git Operations*::
Securely push, pull, and clone repositories from Git hosting services (GitHub, GitLab, Bitbucket) without entering credentials repeatedly
*Server Access*::
Connect to remote servers, VPS instances, and cloud computing resources securely
*Automated Processes*::
Enable scripts and automated build pipelines (CI/CD pipelines) to access repositories and servers without manual intervention

*Key Benefits (no pun intended)*::
*Enhanced Security*::
Much more secure than passwords as they use public-key cryptography
*Convenience*::
Single key can be registered across multiple services
*Revocable*::
Keys can be easily revoked if compromised
*Audit Trail*::
Better tracking of who accessed what and when

== Generating SSH Keys

Before you can use SSH keys, you need to generate a pair: a private key (which you keep secret) and a public key (which you share with services like GitHub or remote servers). The `ssh-keygen` utility is used for this purpose.

=== Choosing a Key Type

It's recommended to use modern, secure algorithms.
*   `ed25519`:: This is currently the recommended algorithm for most use cases due to its strong security properties and smaller key sizes.
*   `rsa`:: While still widely used, if you need RSA, it's best to generate keys with at least 4096 bits for enhanced security.

=== Generating a New Key Pair

To generate an SSH key pair, open your terminal (Git Bash on Windows) and run the `ssh-keygen` command.

==== Recommended: ed25519 Key

This command generates an `ed25519` key with a comment that helps identify it:

[source,sh]
----
ssh-keygen -t ed25519 -C "your_email@example.com"
----

You'll be prompted to:
1.  **Enter a file in which to save the key:** The default location is `~/.ssh/id_ed25519`. You can press Enter to accept this, or specify a custom path (e.g., `~/.ssh/id_ed25519_github` if you plan to use multiple keys).
2.  **Enter passphrase (empty for no passphrase):** It's highly recommended to use a strong passphrase to protect your private key. This passphrase will be requested when you add the key to `ssh-agent`.
3.  **Enter same passphrase again:** Confirm your passphrase.

After generation, two files will be created in your chosen directory (e.g., `~/.ssh/`):
*   `id_ed25519` (or your custom filename): Your **private key**. Keep this file secret and secure.
*   `id_ed25519.pub` (or your custom filename with `.pub`): Your **public key**. This is the content you'll share with remote services.

==== Alternative: RSA Key (4096 bits)

If you require an RSA key (e.g., for compatibility with older systems), use a minimum of 4096 bits:

[source,sh]
----
ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
----

The prompts and resulting files will be similar to the `ed25519` generation, but the default filenames will be `id_rsa` and `id_rsa.pub`.

=== Viewing Your Public Key

Once generated, you can view your public key content to copy it for services like GitHub or GitLab:

[source,sh]
----
cat ~/.ssh/id_ed25519.pub
# Or for a custom key:
cat ~/.ssh/my_custom_key.pub
----

Copy the entire output, starting with `ssh-ed25519` or `ssh-rsa` and ending with your comment, and paste it into the appropriate field on the remote service.

== Do I need more than one SSH key?

It depends. You don't need separate keys for each service from your personal computers. You only need separate keys when separating personal from work identities or when connecting CI/CD pipelines to services. For committing code, you can reuse the same key across multiple repository providers.

Single key approach (simpler):
* One SSH key for all services (GitHub, GitLab, VideoLAN GitLab, etc.)
* Upload the same public key to each service
* Less to manage, works perfectly fine

Multiple keys only make sense if:
* You're separating work/personal identities
* You need different keys for security/compliance requirements
* A key gets compromised and you want to limit blast radius
* You're managing many identities and want organizational clarity

For personal use across multiple services: One key is simpler and sufficient. The services don't care if you reuse the same key â€” they just verify you own the private key that matches the public key you uploaded.

=== SSH Client Configuration (~/.ssh/config)

While `ssh-agent` manages your private keys, the `ssh` *client* program uses the `~/.ssh/config` file to determine *how* it connects to remote servers and *which* keys to use. This file allows you to customize connection settings on a per-host basis or globally, simplifying your SSH commands and automating complex connection setups.

The `~/.ssh/config` file is read by the `ssh` client every time you attempt a connection. It is crucial for specifying non-default settings, including which private key to offer for a particular host.

==== Common Directives

Here are some of the most frequently used directives in `~/.ssh/config`:

*   `Host <alias>`::
    Defines a logical name (alias) for a remote host. All following directives until the next `Host` or end of file apply to this alias. Wildcards (`*` and `?`) can be used to match multiple hosts.
*   `Hostname <real_hostname>`::
    Specifies the actual hostname or IP address of the remote server.
*   `User <username>`::
    Sets the username to use when connecting to the remote host.
*   `Port <port_number>`::
    Defines the port number for the SSH connection (default is 22).
*   `IdentityFile <path_to_private_key>`::
    Specifies the path to the private key file that the `ssh` client should offer to `ssh-agent` for authentication for this host. This is how you tell `ssh` to use a specific key for a specific service (e.g., a different key for GitHub vs. GitLab).
*   `IdentitiesOnly yes`::
    When set to `yes`, `ssh` will only use the keys specified by `IdentityFile` directives (or the default keys if none are specified) and will not try other keys loaded in `ssh-agent`. This can speed up authentication and prevent accidentally offering the wrong key.
*   `AddKeysToAgent yes`::
    Automatically adds the private key specified by `IdentityFile` to `ssh-agent` if it's not already loaded. Requires `ssh-agent` to be running. Note: This automatically adds the key but still prompts for the passphrase if the key is encrypted.
*   `ForwardAgent yes`::
    Enables `ssh-agent` forwarding. This allows your local `ssh-agent` to handle authentication for connections made *from* the remote server you've connected to. Useful for bastion hosts or chaining SSH connections.
*   `ProxyJump <user@jumphost>`::
    Allows you to connect to a target host by first connecting to a jump host (bastion host) and then establishing a second SSH connection through it.

==== Example ~/.ssh/config

Here's an example `~/.ssh/config` file demonstrating several common scenarios:

[source,config]
----
# Global settings for all hosts unless overridden
Host *
  AddKeysToAgent yes
  IdentitiesOnly yes
  ServerAliveInterval 60
  ServerAliveCountMax 5

# Configuration for GitHub
Host github.com
  User git
  IdentityFile ~/.ssh/id_ed25519_github

# Configuration for a specific personal server
Host myserver
  Hostname 192.168.1.100
  User myuser
  Port 2222
  IdentityFile ~/.ssh/id_rsa_personal

# Configuration for a work project that uses a bastion host
Host work-project
  Hostname 10.0.0.50
  User deployuser
  IdentityFile ~/.ssh/id_ed25519_work
  ProxyJump admin@bastion.work.com

# Configuration for a generic bastion host
Host bastion.work.com
  User admin
  IdentityFile ~/.ssh/id_rsa_bastion
----

With this setup, you can simply run `ssh github.com`, `ssh myserver`, or `ssh work-project`, and the `ssh` client will automatically apply the defined settings, including using the correct private key from `ssh-agent`.

== SSH Agent

ssh-agent is a tool that manages SSH keys for you. It stores your private keys securely and automatically uses them when you connect to a server. This means you don't have to enter your passphrase every time you connect.

ssh-agent is preinstalled on macOS and most Linux distributions. On Windows, it requires installation as part of the OpenSSH Client feature.

=== SSH Agent GUI recommendation

I recommend checking out https://github.com/frequency403/OpenSSH-GUI for a graphical user interface to manage your OpenSSH keys.

=== Alternative SSH Agents

There are alternative SSH agents available, such as Pageant for Windows and Keychain for macOS. Many popular password managers (1Password, Bitwarden) also provide their own SSH agents that can replace ssh-agent. The choice is yours.

=== Installing SSH Agent

==== Linux and macOS

ssh-agent is preinstalled and available out of the box. No installation is needed.

If missing (rare), install the `openssh-client` package:

- On Ubuntu/Debian: `sudo apt install openssh-client`
- On Fedora: `sudo dnf install openssh-clients`
- On macOS: Already included; use Homebrew if needed: `brew install openssh`

==== Windows

On Windows 10 version 1803 and later:

1. Go to `Settings > Apps > Optional features`.
2. Click `Add a feature`, search for "OpenSSH Client", and install it.

Alternatively, via PowerShell (as Administrator):

[source,powershell]
----
Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0
----

If using Windows Subsystem for Linux (WSL), the Linux distros that run inside of WSL do not have access to the Windows ssh-agent that you installed. You will have to either create a bridge or relay to access windows ssh-agent from inside of WSL or install an internal copy by following the Linux instructions.

Git for Windows (Git Bash) also includes its own ssh-agent. Git Bash is based on MSYS2, a minimal GNU system environment for Windows (GNU is the OS toolset for most Linux distributions, while Linux itself is a kernel which runs those tools).

Once installed, you can start the agent manually using the instructions below.

=== Starting SSH Agent Manually

==== Linux and macOS

Start the agent with:

[source,sh]
----
ssh-agent $SHELL
----

in a new shell session.

Alternatively, in the existing shell session, use:

[source,sh]
----
eval "$(ssh-agent -s)"
----

This starts the agent and sets environment variables for the current shell session.

==== Windows

Assuming OpenSSH Client is installed, open PowerShell as Administrator and run:

[source,powershell]
----
Start-Service ssh-agent
----

For the current session in PowerShell (non-admin), start the agent and set environment variables:

[source,powershell]
----
& ssh-agent -s | Invoke-Expression
----

For Git Bash or compatible shells, use `eval "$(ssh-agent -s)"`.

You can verify if the SSH agent is running and check for loaded keys using the methods below.

=== Checking if SSH Agent is Running

You can check if the SSH agent is running and list loaded keys with:

[source,sh]
----
ssh-add -l
----

If no identities are loaded or the agent isn't running, this will output an error like "The agent has no identities" or "Could not open a connection to your authentication agent."

Alternatively, check for the process:

- On Linux/macOS: `pgrep ssh-agent`
- On Windows (PowerShell): `Get-Process ssh-agent -ErrorAction SilentlyContinue`

Once the agent is running, you can add your private keys to it so SSH can use them for authentication.

=== Adding Keys to SSH Agent

To add your private key to the agent, run the following command (replace `~/.ssh/id_rsa` with the path to your private key if different):

[source,sh]
----
ssh-add ~/.ssh/id_rsa
----

It's important to note that `ssh-agent` does not automatically discover keys in `~/.ssh` or from your `~/.ssh/config` file. This is a security feature, requiring explicit action to load keys into the agent's memory, ensuring you control which sensitive keys are available for use.

You can add multiple keys by running the command for each one, for example `ssh-add ~/.ssh/id_ed25519`. You'll be prompted for the passphrase of each key added.

While `ssh-add` does not directly support wildcard patterns (e.g., `ssh-add ~/.ssh/*`), you can use your shell's capabilities (like Bash or Zsh) to expand wildcards into a list of specific files.

For example, to add all private keys in your `~/.ssh` directory that follow common naming conventions (e.g., `id_*` or ending with `.pem`):

[source,sh]
----
for KEY in ~/.ssh/id_* ~/.ssh/*.pem; do
  if [ -f "$KEY" ]; then
    ssh-add "$KEY"
  fi
done
----

This loop iterates through files matching the patterns and adds each existing file to the agent.

=== Automatic Startup

Instead of starting the agent manually each session, you can configure ssh-agent to start automatically on login. This ensures the agent runs persistently without manual intervention each time. You can also set up your shell profile (e.g., `~/.bashrc` or `~/.profile`) to automatically add keys after the agent starts, though you'll still need to enter the passphrase initially unless using additional tools like keychain (on Linux/macOS) or storing passphrases securely.

For easy automated installation and configuration, run the provided setup scripts:

* Linux: xref:attachment$ssh-keys/setup-linux.sh[setup-linux.sh]
* Windows: xref:attachment$ssh-keys/setup-windows.ps1[setup-windows.ps1]

These scripts install dependencies if needed and configure automatic startup with key management. Note: No script for macOS, as it often starts automatically; use the manual instructions below if needed.

To configure manually per OS, follow the instructions below:

==== Linux

The simplest way is to add the start command to your shell profile for user sessions.

1. Edit `~/.bashrc` or `~/.profile` (depending on your shell; bash uses `.bashrc`):

[source,sh]
----
if [ -z "$SSH_AUTH_SOCK" ]; then
    eval "$(ssh-agent -s)"
    ssh-add ~/.ssh/id_rsa  # Add your key(s); passphrase prompted once per boot
fi
----
+
2. Save and reload: `source ~/.bashrc`

For more advanced persistent agent across reboots (using `keychain` tool, recommended for passphrase reuse):

1. Install keychain: `sudo apt install keychain` (Ubuntu) or equivalent.
2. Add to `~/.bashrc`:

[source,sh]
----
eval $(keychain --eval --agents ssh id_rsa)
----
+
This starts the agent only if not running and reuses the passphrase across sessions.

Alternatively, create a user systemd service for per-user automatic start:

1. Create `~/.config/systemd/user/ssh-agent.service`:

[source]
----
[Unit]
Description=SSH key agent

[Service]
Type=simple
Environment=DISPLAY=:0  # If needed for GUI
ExecStart=/usr/bin/ssh-agent -D -a $XDG_RUNTIME_DIR/ssh-agent.socket
ExecStop=/usr/bin/ssh-agent -k

[Install]
WantedBy=default.target
----
+
2. Reload and enable:

[source,sh]
----
systemctl --user daemon-reload
systemctl --user enable ssh-agent.service
systemctl --user start ssh-agent.service
----
+
3. Add to `~/.bashrc` or `~/.profile`:

[source,sh]
----
export SSH_AUTH_SOCK="$XDG_RUNTIME_DIR/ssh-agent.socket"
export SSH_AGENT_PID=  # Let ssh-agent set it
----

==== macOS

macOS often starts ssh-agent automatically via launchd for GUI sessions. To ensure it for all sessions:

1. Add to `~/.zshrc` or `~/.bash_profile`:

[source,sh]
----
eval "$(ssh-agent -s)"
ssh-add -q ~/.ssh/id_rsa  # Quiet add; passphrase prompted
----

For persistent passphrase management, use `ssh-add -K` (adds to keychain):

[source,sh]
----
ssh-add --apple-use-keychain ~/.ssh/id_rsa
----

And add to profile:

[source,sh]
----
ssh-add -q --apple-use-keychain ~/.ssh/id_rsa 2>/dev/null
----

To create a launchd plist for automatic start:

1. Create `~/Library/LaunchAgents/org.openbsd.ssh-agent.plist`:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>org.openbsd.ssh-agent</string>
    <key>ProgramArguments</key>
    <array>
        <string>/usr/bin/ssh-agent</string>
        <string>-l</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <false/>
    <key>SocketActivation</key>
    <dict>
        <key>ListenStreams</key>
        <array>
            <dict>
                <key>SockServiceName</key>
                <string>ssh-agent</string>
            </dict>
        </array>
    </dict>
</dict>
</plist>
----
+
2. Load it: `launchctl load ~/Library/LaunchAgents/org.openbsd.ssh-agent.plist`

==== Windows

After installing OpenSSH Client:

. Open PowerShell as Administrator.
. Set the service to automatic startup:

[source,powershell]
----
Set-Service -Name ssh-agent -StartupType Automatic
----
+
. Start the service:

[source,powershell]
----
Start-Service ssh-agent
----

The service will now start automatically on boot and run persistently.

To add keys on startup, you can create a scheduled task or add to your PowerShell profile (`$PROFILE`), but for passphrase-protected keys, you'll need to enter the passphrase manually or use Windows Credential Manager integration (via `ssh-add` with pageant-like tools or PowerShell scripts).

For Git Bash users, add to `~/.bashrc`:

[source,sh]
----
eval $(ssh-agent -s)
ssh-add ~/.ssh/id_rsa
----

== Gotchas with SSH tools

While the config file can reference SSH keys in other directories, Git GUI and many other SSH key management tools do not recognize any keys that are not directly present in the ~/.ssh directory, because they only look in the predefined directory and do not parse the config file to search for keys.

GitHub will fail to conduct operations if no SSH keys are registered to the ssh-agent process, even if those keys are mentioned in the config file.

Conventional advice says that the SSH-agent tool is only necessary if you intend to use SSH keys that are password-protected. However, many tools, like GitHub Desktop, are intimately dependent on ssh-agent for their core operations, despite no reason for it to be required.

=== Windows: Git Uses Its Own SSH Client (Critical!)

[IMPORTANT]
====
This is a *major source of confusion* on Windows. Even if you have set up OpenSSH correctly and `ssh -T git@github.com` works perfectly in PowerShell, Git operations like `git push` can still fail with "Permission denied (publickey)".
====

*The Problem:* Git for Windows bundles its own SSH client from MSYS2 (located at `C:\Program Files\Git\usr\bin\ssh.exe`). By default, Git uses this bundled SSH instead of the Windows OpenSSH client (`C:\Windows\System32\OpenSSH\ssh.exe`). The bundled SSH does *not* have access to the Windows ssh-agent service where your keys are loaded.

*Symptoms:*

* `ssh -T git@github.com` works in PowerShell: "Welcome to GitHub!"
* `git push` fails: "Permission denied (publickey)"
* `ssh-add -l` shows your keys loaded
* You've verified the remote URL is correct with `git remote -v`

*The Fix:* Configure Git to use the Windows OpenSSH client globally:

[source,powershell]
----
git config --global core.sshCommand "C:/Windows/System32/OpenSSH/ssh.exe"
----

This tells Git to use the Windows SSH client that has access to the Windows ssh-agent service.

*Verification:*

[source,powershell]
----
# Check the current SSH command configuration
git config --get core.sshCommand

# Test that Git operations now work
git ls-remote origin
----

[TIP]
====
Add this configuration step to your Windows setup checklist. This single line of configuration can save hours of frustrating debugging.
====

*Why This Happens:* Git for Windows is built on MSYS2, a minimal GNU environment for Windows. It includes its own versions of Unix tools including SSH. While this provides a consistent experience across platforms, it creates a split where the Windows ecosystem (OpenSSH, ssh-agent service, Credential Manager) and the Git/MSYS2 ecosystem operate independently. Neither the Git developers nor Microsoft have addressed this integration gap, leaving users to discover the solution through trial and error.

*Alternative Solutions:*

. **Use HTTPS instead of SSH:** Configure your remote to use `https://` URLs instead of `git@` SSH URLs. This uses Git's credential helper system instead of SSH keys.

. **Use Git Bash exclusively:** Git Bash can start its own ssh-agent that the bundled SSH can access. Add to `~/.bashrc`:

[source,sh]
----
eval $(ssh-agent -s)
ssh-add ~/.ssh/id_ed25519
----
+
However, this means you need to use Git Bash for all Git operations, not PowerShell or other terminals.

. **Use a third-party SSH agent:** Tools like Pageant (from PuTTY) or 1Password's SSH agent can bridge this gap, but add complexity.
